local DrRayLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/AZYsGithub/DrRay-UI-Library/main/DrRay.lua"))()

local window = DrRayLibrary:Load("Niagra Da Hood", "Default")

local tab = DrRayLibrary.newTab("Main", "ImageIdHere")

tab.newButton("Silent Aim", "Click To Activate!", function()
    
getgenv().Silent = {
    Setting = {
        IsTargetting = true,
        Prediction = 0.1367901647392,
        TargetPart = "HumanoidRootPart",
        WallCheck = true,
        FOV = {
            Radius = 70,
            Visible = false
        }
    }
}

local Inset, Mouse, Client, Vector2New, Cam =
    game:GetService("GuiService"):GetGuiInset().Y,
    game.Players.LocalPlayer:GetMouse(),
    game.Players.LocalPlayer,
    Vector2.new,
    workspace.CurrentCamera
local Targetting

local FOV = Drawing.new("Circle")
FOV.Transparency = 0.5
FOV.Thickness = 1.6
FOV.Color = Color3.fromRGB(230, 230, 250)
FOV.Filled = true

local UpdateFOV = function(Radius)
    if (not FOV) then
        return
    end

    FOV.Position = Vector2New(Mouse.X, Mouse.Y + (Inset))
    FOV.Visible = getgenv().Silent.Setting.FOV["Visible"]
    FOV.Radius = (Radius) * 3.067

    return FOV
end

task.spawn(function() while task.wait() do UpdateFOV(getgenv().Silent.Setting.FOV["Radius"]) end end)

local WallCheck = function(destination, ignore)
    if getgenv().Silent.Setting.WallCheck then
        local Origin = Cam.CFrame.p
        local CheckRay = Ray.new(Origin, destination - Origin)
        local Hit = game.workspace:FindPartOnRayWithIgnoreList(CheckRay, ignore)
        return Hit == nil
    else
        return true
    end
end

local getClosestChar = function()
    local Target, Closest = nil, 1 / 0
    for _, v in pairs(game.Players:GetPlayers()) do
        if (v.Character and v ~= Client and v.Character:FindFirstChild("HumanoidRootPart")) then
            local Position, OnScreen = Cam:WorldToScreenPoint(v.Character.HumanoidRootPart.Position)
            local Distance = (Vector2New(Position.X, Position.Y) - Vector2New(Mouse.X, Mouse.Y)).Magnitude

            if
                (FOV.Radius > Distance and Distance < Closest and OnScreen and
                    WallCheck(v.Character.HumanoidRootPart.Position, {Client, v.Character}))
             then
                Closest = Distance
                Target = v
            end
        end
    end
    return Target
end

local Old
Old =
    hookmetamethod(
    game,
    "__index",
    function(self, key)
        if self:IsA("Mouse") and key == "Hit" then
            Targetting = getClosestChar()
            if Targetting ~= nil then
                return Targetting.Character[getgenv().Silent.Setting.TargetPart].CFrame +
                    (Targetting.Character[getgenv().Silent.Setting.TargetPart].Velocity *
                        getgenv().Silent.Setting.Prediction)
            end
        end
        return Old(self, key)
    end
)
end)

tab.newButton("Box ESP", "puts a box around players", function()
 
--// Universal Box ESP (Works on Arsenal and other games)
 
-- settings
local settings = {
   defaultcolor = Color3.fromRGB(255,0,0),
   teamcheck = false,
   teamcolor = true
};
 
-- services
local runService = game:GetService("RunService");
local players = game:GetService("Players");
 
-- variables
local localPlayer = players.LocalPlayer;
local camera = workspace.CurrentCamera;
 
-- functions
local newVector2, newColor3, newDrawing = Vector2.new, Color3.new, Drawing.new;
local tan, rad = math.tan, math.rad;
local round = function(...) local a = {}; for i,v in next, table.pack(...) do a[i] = math.round(v); end return unpack(a); end;
local wtvp = function(...) local a, b = camera.WorldToViewportPoint(camera, ...) return newVector2(a.X, a.Y), b, a.Z end;
 
local espCache = {};
local function createEsp(player)
   local drawings = {};
 
   drawings.box = newDrawing("Square");
   drawings.box.Thickness = 1;
   drawings.box.Filled = false;
   drawings.box.Color = settings.defaultcolor;
   drawings.box.Visible = false;
   drawings.box.ZIndex = 2;
 
   drawings.boxoutline = newDrawing("Square");
   drawings.boxoutline.Thickness = 3;
   drawings.boxoutline.Filled = false;
   drawings.boxoutline.Color = newColor3();
   drawings.boxoutline.Visible = false;
   drawings.boxoutline.ZIndex = 1;
 
   espCache[player] = drawings;
end
 
local function removeEsp(player)
   if rawget(espCache, player) then
       for _, drawing in next, espCache[player] do
           drawing:Remove();
       end
       espCache[player] = nil;
   end
end
 
local function updateEsp(player, esp)
   local character = player and player.Character;
   if character then
       local cframe = character:GetModelCFrame();
       local position, visible, depth = wtvp(cframe.Position);
       esp.box.Visible = visible;
       esp.boxoutline.Visible = visible;
 
       if cframe and visible then
           local scaleFactor = 1 / (depth * tan(rad(camera.FieldOfView / 2)) * 2) * 1000;
           local width, height = round(4 * scaleFactor, 5 * scaleFactor);
           local x, y = round(position.X, position.Y);
 
           esp.box.Size = newVector2(width, height);
           esp.box.Position = newVector2(round(x - width / 2, y - height / 2));
           esp.box.Color = settings.teamcolor and player.TeamColor.Color or settings.defaultcolor;
 
           esp.boxoutline.Size = esp.box.Size;
           esp.boxoutline.Position = esp.box.Position;
       end
   else
       esp.box.Visible = false;
       esp.boxoutline.Visible = false;
   end
end
 
-- main
for _, player in next, players:GetPlayers() do
   if player ~= localPlayer then
       createEsp(player);
   end
end
 
players.PlayerAdded:Connect(function(player)
   createEsp(player);
end);
 
players.PlayerRemoving:Connect(function(player)
   removeEsp(player);
end)
 
runService:BindToRenderStep("esp", Enum.RenderPriority.Camera.Value, function()
   for player, drawings in next, espCache do
       if settings.teamcheck and player.Team == localPlayer.Team then
           continue;
       end
 
       if drawings and player ~= localPlayer then
           updateEsp(player, drawings);
       end
   end
end)
end)

tab.newButton("Mobile Silent Aim", "uwu!", function()
 
getgenv().HitPart = "HumanoidRootPart"
getgenv().Prediction = 0.1485436
getgenv().Enabled = true

-- fov settings
getgenv().ShowFOV = true
getgenv().Filled = false
getgenv().FOVSize = 150
getgenv().FOVTransparency = 1
getgenv().FOVThickness = 2.0
getgenv().FOVColor = Color3.new(0,0,0)

SilentAimFOVCircle = Drawing.new("Circle")
SilentAimFOVCircle.Color = getgenv().FOVColor
SilentAimFOVCircle.Visible = getgenv().ShowFOV
SilentAimFOVCircle.Filled = getgenv().Filled
SilentAimFOVCircle.Radius = getgenv().FOVSize
SilentAimFOVCircle.Transparency = getgenv().FOVTransparency
SilentAimFOVCircle.Thickness = getgenv().FOVThickness

Players = game:GetService("Players")
Camera = workspace.CurrentCamera

SilentAimFOVCircle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2  - (game:GetService("GuiService"):GetGuiInset().Y/2))

local function getClosestPlayerToCenter()
    local centerScreenPosition = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2  - (game:GetService("GuiService"):GetGuiInset().Y/2))
    local closestPlayer
    local closestDistance = math.huge
    local localPlayer = game.Players.LocalPlayer

    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local playerRootPart = player.Character.HumanoidRootPart
            local screenPosition, onScreen = workspace.CurrentCamera:WorldToViewportPoint(playerRootPart.Position)

            if onScreen then
                local distance = (centerScreenPosition - Vector2.new(screenPosition.X, screenPosition.Y)).Magnitude

                if distance < closestDistance and distance <= SilentAimFOVCircle.Radius then
                    closestPlayer = player
                    closestDistance = distance
                end
            end
        end
    end

    return closestPlayer
end


local SilentTarget = nil

game:GetService("RunService").RenderStepped:Connect(function()
    SilentTarget = getClosestPlayerToCenter()
end)

local mt = getrawmetatable(game)
local old = mt.namecall
setreadonly(mt, false)
mt.namecall = newcclosure(function(...)
    local args = {...}
    if getgenv().Enabled and SilentTarget~=nil and SilentTarget.Character and getnamecallmethod() == "FireServer" and args[2] == "UpdateMousePos" then
            args[3] = SilentTarget.Character[getgenv().HitPart].Position + (SilentTarget.Character[getgenv().HitPart].Velocity*getgenv().Prediction)
        return old(unpack(args))
    end
    return old(...)
end)
end)


local tab = DrRayLibrary.newTab("Random", "ImageIdHere")
 
tab.newButton("Fly!", "Click To Fly!", function()
 
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local flying = false

-- Settings
local flySpeed = 100
local flightForce = Instance.new("BodyVelocity")
flightForce.MaxForce = Vector3.new(100000, 100000, 100000)
flightForce.Velocity = Vector3.new(0, 0, 0)

local gyro = Instance.new("BodyGyro")
gyro.MaxTorque = Vector3.new(100000, 100000, 100000) -- Full control over rotation
gyro.D = 100 -- Increased damping to reduce shaking
gyro.P = 6000 -- Increased power to stabilize movement

-- UI Prompt to toggle flying (optional)
local UIS = game:GetService("UserInputService")

-- Function to start flying
local function startFlying()
    flying = true
    flightForce.Parent = rootPart
    gyro.Parent = rootPart
    -- We remove PlatformStand to allow movement
    humanoid.PlatformStand = false 
end

-- Function to stop flying
local function stopFlying()
    flying = false
    flightForce.Parent = nil
    gyro.Parent = nil
end

-- Toggle flying with a key (E key in this case)
UIS.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.E then
        if flying then
            stopFlying()
        else
            startFlying()
        end
    end
end)

-- Update flight movement based on player input
local function flyMovement()
    if flying then
        local moveDirection = Vector3.new(0, 0, 0)
        
        if UIS:IsKeyDown(Enum.KeyCode.W) then
            moveDirection = moveDirection + workspace.CurrentCamera.CFrame.LookVector
        end
        if UIS:IsKeyDown(Enum.KeyCode.S) then
            moveDirection = moveDirection - workspace.CurrentCamera.CFrame.LookVector
        end
        if UIS:IsKeyDown(Enum.KeyCode.A) then
            moveDirection = moveDirection - workspace.CurrentCamera.CFrame.RightVector
        end
        if UIS:IsKeyDown(Enum.KeyCode.D) then
            moveDirection = moveDirection + workspace.CurrentCamera.CFrame.RightVector
        end
        if UIS:IsKeyDown(Enum.KeyCode.Space) then
            moveDirection = moveDirection + Vector3.new(0, 1, 0)
        end
        if UIS:IsKeyDown(Enum.KeyCode.LeftControl) then
            moveDirection = moveDirection - Vector3.new(0, 1, 0)
        end

        flightForce.Velocity = moveDirection * flySpeed

        -- Stabilize the BodyGyro to match the camera's rotation
        gyro.CFrame = workspace.CurrentCamera.CFrame
    end
end

-- Update the player's flight every frame
game:GetService("RunService").RenderStepped:Connect(flyMovement)


end)

